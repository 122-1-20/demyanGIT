PyPy - как он может победить CPython?
Из блога Google с открытым исходным кодом :

PyPy-это повторное воплощение Python в Python, используя передовые методы чтобы попытаться достичь лучшей производительности чем CPython. Много лет упорного труда наконец-то все окупилось. Наша скорость результаты часто бьют CPython, ранжирование от того, чтобы быть немного медленнее, к ускорение до 2х в реальном времени код приложения, для ускорения до 10х на небольших отметках.


"PyPy is a reimplementation of Python in Python"-это довольно обманчивый способ описания PyPy, IMHO, хотя технически это верно.

Существует две основные части PyPy.

Структура перевода
Переводчик


Фреймворк перевода - это компилятор. Он компилирует код RPython вплоть до C (или других целевых объектов), автоматически добавляя такие аспекты, как сборка мусора и компилятор JIT. Он не может обрабатывать произвольный код Python, только RPython.

RPython-это подмножество нормального Python; весь код RPython - это код Python, но не наоборот. Нет никакого формального определения RPython, потому что RPython-это в основном просто "подмножество Python, которое может быть переведено с помощью структуры перевода PyPy". Но для того, чтобы быть переведенным, код RPython должен быть статически типизирован (типы выводятся, вы их не объявляете, но это все равно строго один тип на переменную), и вы также не можете делать такие вещи, как объявление/изменение функций/классов во время выполнения.

Тогда переводчик-это обычный Python переводчик, написанный на RPython.

Поскольку код RPython является обычным кодом Python, вы можете запустить его на любом интерпретаторе Python. Но ни одно из утверждений о скорости PyPy не связано с запуском его таким образом; это просто для быстрого цикла тестирования, потому что перевод интерпретатора занимает много времени.

Если это понять, то сразу станет ясно, что рассуждения о PyPyPy или PyPyPyPy на самом деле не имеют никакого смысла. У вас есть переводчик, написанный на языке RPython. Вы переводите его в код C, который быстро выполняет Python. Там процесс останавливается; нет больше RPython, чтобы ускорить его обработку снова.

Так что "How is it possible for PyPy to be faster than CPython" также становится довольно очевидным. PyPy имеет лучшую реализацию, включая компилятор JIT (обычно он не так быстр без компилятора JIT, я думаю, что это означает, что PyPy только быстрее для программ, подверженных компиляции JIT). CPython никогда не был задуман как сильно оптимизирующая реализация языка Python (хотя они действительно пытаются сделать его сильно оптимизированной реализацией, если вы понимаете разницу).

Действительно инновационный бит проекта PyPy заключается в том, что они не пишут сложные схемы GC или компиляторы JIT вручную. Они пишут интерпретатор относительно прямолинейно в RPython, и для всех RPython является более низким уровнем, чем Python, это все еще объектно-ориентированный язык сбора мусора, гораздо более высокий уровень, чем C. Затем платформа перевода автоматически добавляет такие вещи, как GC и JIT. Таким образом, платформа перевода-это огромное усилие, но она одинаково хорошо применяется к интерпретатору PyPy python, однако они меняют свою реализацию, позволяя гораздо больше свободы в экспериментах по повышению производительности (не беспокоясь о введении ошибок GC или обновлении компилятора JIT, чтобы справиться с изменениями). Это также означает, что когда они приступят к реализации интерпретатора Python3, он автоматически получит те же преимущества. И любые другие интерпретаторы, написанные с использованием фреймворка PyPy (которых существует несколько на разных стадиях польского языка). И все интерпретаторы, использующие фреймворк PyPy, автоматически поддерживают все платформы, поддерживаемые фреймворком.

Таким образом, истинное преимущество проекта PyPy состоит в том, чтобы отделить (насколько это возможно) все части реализации эффективного платформенно-независимого интерпретатора для динамического языка. А затем придумайте одну хорошую реализацию их в одном месте, которую можно повторно использовать во многих интерпретаторах. Это не немедленная победа, как "моя программа Python теперь работает быстрее", но это отличная перспектива на будущее.

И он может запустить вашу программу Python быстрее (возможно).


К1. Как же это возможно?

Ручное управление памятью (что и делает CPython с ее подсчетом) в некоторых случаях может быть медленнее автоматического управления.

Ограничения в реализации интерпретатора CPython исключают определенные оптимизации, которые может выполнить PyPy (например. мелкозернистые замки).

Как уже упоминал Марсело, JIT. Возможность на лету подтвердить тип объекта может избавить вас от необходимости делать несколько разыменований указателей, чтобы в конечном итоге получить метод, который вы хотите вызвать.

Q2. Какая реализация Python была использована для реализации PyPy?

Интерпретатор PyPy реализован в RPython, который является статически типизированным подмножеством Python (язык, а не интерпретатор CPython)




Q3. И каковы шансы на то, что PyPyPy или PyPyPyPy побьют их счет?

Это будет зависеть от реализации этих гипотетических интерпретаторов. Если бы один из них, например, взял исходный код, сделал какой-то анализ на нем и преобразовал его непосредственно в жесткий целевой код assembly после выполнения в течение некоторого времени, я думаю, что это было бы намного быстрее, чем CPython.

Update: недавно на тщательно обработанном примере PyPy превзошел аналогичную программу C, скомпилированную с gcc -O3 . Это надуманный случай, но он демонстрирует некоторые идеи.














Как PyPy может быть быстрее Cpython
Я читал PyPy -- как он может победить CPython? и бесчисленное множество других вещей, но я не могу понять, как что-то, написанное в Python, может быть быстрее, чем само python.

Единственный способ, который я могу придумать, - это то, что PyPy каким-то образом обходит C и напрямую компилируется в инструкции языка assembly. Если это так, то все в порядке.

Может кто-нибудь объяснить мне, как работает PyPy? Мне нужен простой ответ.

Я люблю python и хочу начать вносить свой вклад. PyPy выглядит как удивительное место для начала, независимо от того, тянут ли они мой код или нет. Но я не могу понять из краткого исследования, которое я сделал.




Самый простой способ понять PyPy-это забыть, что он реализован в Python.

На самом деле это не так, во всяком случае, это реализовано в RPython. RPython можно запустить с помощью интерпретатора Python, но код Python не может быть скомпилирован компилятором RPython (платформа перевода PyPy). RPython-это подмножество Python, но части, которые являются "left out", достаточно существенны, чтобы программирование в RPython сильно отличалось от программирования обычно в Python.

Итак, поскольку код Python нельзя рассматривать как код RPython, а идиоматические программы RPython "look and feel" очень отличаются от идиоматических программ Python, давайте проигнорируем связь между ними и рассмотрим придуманный пример.

Представьте, что я разработал новый язык, Frobble, с компилятором. И я написал интерпретатор Python в Frobble. Я утверждаю, что мой "FrobblePython" переводчик часто значительно быстрее, чем CPython переводчик.

Это кажется вам странным или невозможным? Конечно, нет. Новый интерпретатор Python может быть либо быстрее, либо медленнее, чем интерпретатор CPython (или, что более вероятно, быстрее в некоторых вещах и медленнее в других, варьируя поля). Будет ли это быстрее или нет, будет зависеть от реализации FrobblePython, а также от характеристик производительности кода, скомпилированного моим компилятором Frobble.

Именно так вы должны думать о интерпретаторе PyPy. Тот факт, что язык, используемый для его реализации, RPython, оказывается способным интерпретироваться интерпретатором Python (с теми же внешними результатами, что и компиляция программы RPython и ее запуск), совершенно не имеет отношения к пониманию того, насколько он быстр. Все, что имеет значение, - это реализация интерпретатора PyPy и характеристики производительности кода, скомпилированного компилятором RPython (например, тот факт, что компилятор RPython может автоматически добавлять определенные виды возможностей JITing в программы, которые он компилирует).



PyPy сам записывается в RPython, который является ограниченным подмножеством Python. Хотя вы можете запустить его поверх CPython, это очень медленно, поэтому вместо этого вы переводите этот RPython в C, следовательно, обходя интерпретацию. Это, в теории, уже может быть быстрее, чем CPython, но на самом деле довольно немного медленнее. Кроме того, реализован компилятор just in time (также в RPython), который компилирует Python в ассемблер.

Короче говоря, нет никакой фактической двойной интерпретации, связанной в любой момент времени во время выполнения, поэтому нет никакой проблемы.




